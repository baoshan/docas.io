// Generated by CoffeeScript 1.3.1
(function() {
  var Fairy, Queue, enter_cleanup_mode, exiting, fairy_id, logging_registered_workers, os, prefix, redis, registered_workers, server_ip, uuid,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  uuid = require('node-uuid');

  redis = require('redis');

  os = require('os');

  prefix = 'FAIRY';

  exports.connect = function(options) {
    var client;
    if (options == null) {
      options = {};
    }
    client = redis.createClient(options.port, options.host, options.options);
    if (options.password != null) {
      client.auth(options.password);
    }
    return new Fairy(client);
  };

  exiting = false;

  registered_workers = [];

  logging_registered_workers = function() {
    var registered_worker, _i, _len, _results;
    console.log("\nFairy is waiting for " + registered_workers.length + " workers to clean-up before exit:");
    _results = [];
    for (_i = 0, _len = registered_workers.length; _i < _len; _i++) {
      registered_worker = registered_workers[_i];
      registered_worker = registered_worker.split('|');
      _results.push(console.log("  * Client Id: " + registered_worker[0] + ", Task: " + registered_worker[1]));
    }
    return _results;
  };

  enter_cleanup_mode = function() {
    logging_registered_workers();
    if (!registered_workers.length) {
      return process.exit();
    }
    return exiting = true;
  };

  process.on('SIGINT', enter_cleanup_mode);

  process.on('SIGUSR2', enter_cleanup_mode);

  process.on('uncaughtException', function(err) {
    console.log('Uncaught Exception:');
    console.log(err.stack);
    console.log('Fairy will block all processing groups before exit.');
    return enter_cleanup_mode();
  });

  process.on('exit', function() {
    return console.log("Fairy cleaned up, exiting...");
  });

  server_ip = function() {
    var address, addresses, card, _i, _len, _ref;
    _ref = os.networkInterfaces();
    for (card in _ref) {
      addresses = _ref[card];
      for (_i = 0, _len = addresses.length; _i < _len; _i++) {
        address = addresses[_i];
        if (!address.internal && address.family === 'IPv4') {
          return address.address;
        }
      }
    }
    return 'UNKNOWN_IP';
  };

  fairy_id = 0;

  Fairy = (function() {

    Fairy.name = 'Fairy';

    function Fairy(redis) {
      this.redis = redis;
      this.id = fairy_id++;
      this.queue_pool = {};
    }

    Fairy.prototype.key = function(key) {
      return "" + prefix + ":" + key;
    };

    Fairy.prototype.queue = function(name) {
      if (this.queue_pool[name]) {
        return this.queue_pool[name];
      }
      this.redis.sadd(this.key('QUEUES'), name);
      return this.queue_pool[name] = new Queue(this, name);
    };

    Fairy.prototype.queues = function(callback) {
      var _this = this;
      return this.redis.smembers(this.key('QUEUES'), function(err, res) {
        return callback(res.map(function(name) {
          return _this.queue(name);
        }));
      });
    };

    Fairy.prototype.statistics = function(callback) {
      if (typeof callback !== 'function') {
        return;
      }
      return this.queues(function(queues) {
        var i, queue, result, total_queues, _i, _len, _results;
        if (!(total_queues = queues.length)) {
          return callback([]);
        }
        result = [];
        _results = [];
        for (i = _i = 0, _len = queues.length; _i < _len; i = ++_i) {
          queue = queues[i];
          _results.push((function(queue, i) {
            return queue.statistics(function(statistics) {
              result[i] = statistics;
              if (!--total_queues ? callback : void 0) {
                return callback(result);
              }
            });
          })(queue, i));
        }
        return _results;
      });
    };

    return Fairy;

  })();

  Queue = (function() {

    Queue.name = 'Queue';

    function Queue(fairy, name) {
      this.fairy = fairy;
      this.name = name;
      this.clear = __bind(this.clear, this);

      this.reschedule = __bind(this.reschedule, this);

      this._continue_group = __bind(this._continue_group, this);

      this._process = __bind(this._process, this);

      this._try_exit = __bind(this._try_exit, this);

      this._poll = __bind(this._poll, this);

      this.regist = __bind(this.regist, this);

      this.enqueue = __bind(this.enqueue, this);

      this.redis = fairy.redis;
    }

    Queue.prototype.key = function(key) {
      return "" + prefix + ":" + key + ":" + this.name;
    };

    Queue.prototype.polling_interval = 5;

    Queue.prototype.retry_delay = 0.1 * 1000;

    Queue.prototype.retry_limit = 2;

    Queue.prototype.recent_size = 10;

    Queue.prototype.slowest_size = 10;

    Queue.prototype.enqueue = function() {
      var args, callback, multi, _i;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), callback = arguments[_i++];
      if (typeof callback !== 'function') {
        args.push(callback);
        callback = void 0;
      }
      args.push(Date.now());
      multi = this.redis.multi();
      multi.rpush(this.key('SOURCE'), JSON.stringify([uuid.v4()].concat(__slice.call(args))));
      multi.hincrby(this.key('STATISTICS'), 'total', 1);
      multi.sadd(this.key('GROUPS'), args[0]);
      return multi.exec(callback);
    };

    Queue.prototype.regist = function(handler) {
      var worker_id,
        _this = this;
      this.handler = handler;
      registered_workers.push("" + this.fairy.id + "|" + this.name);
      worker_id = uuid.v4();
      this.redis.hset(this.key('WORKERS'), worker_id, "" + (os.hostname()) + "|" + (server_ip()) + "|" + process.pid + "|" + (Date.now()));
      process.on('uncaughtException', function(err) {
        if (_this._handler_callback) {
          console.log("Worker " + (worker_id.split('-')[0]) + " of task " + _this.name + " will block current processing group");
          return _this._handler_callback({
            "do": 'block',
            message: err.stack
          }, null);
        } else {
          return _this._try_exit();
        }
      });
      process.on('exit', function() {
        return _this.redis.hdel(_this.key('WORKERS'), worker_id);
      });
      return this._poll();
    };

    Queue.prototype._poll = function() {
      var _this = this;
      if (exiting) {
        return this._try_exit();
      }
      this.redis.watch(this.key('SOURCE'));
      return this.redis.lindex(this.key('SOURCE'), 0, function(err, res) {
        var multi, task;
        if (res) {
          task = JSON.parse(res);
          _this.processing_id = task[0];
          multi = _this.redis.multi();
          multi.lpop(_this.key('SOURCE'));
          multi.rpush("" + (_this.key('QUEUED')) + ":" + task[1], res);
          return multi.exec(function(multi_err, multi_res) {
            if (!multi_res || multi_res[1] !== 1) {
              return _this._poll();
            }
            return _this._process(task);
          });
        } else {
          _this.redis.unwatch();
          return setTimeout(_this._poll, _this.polling_interval);
        }
      });
    };

    Queue.prototype._try_exit = function() {
      registered_workers.splice(registered_workers.indexOf("" + this.fairy.id + "|" + this.name, 1));
      if (!registered_workers.length) {
        process.exit();
      }
      return logging_registered_workers();
    };

    Queue.prototype._process = function(task) {
      var call_handler, errors, handler_callback, processing, requeue, retry_count, start_time,
        _this = this;
      if (exiting) {
        return (requeue = function() {
          _this.redis.watch("" + (_this.key('QUEUED')) + ":" + task[1]);
          return _this.redis.lrange("" + (_this.key('QUEUED')) + ":" + task[1], 0, -1, function(err, res) {
            var multi;
            multi = _this.redis.multi();
            multi.lpush.apply(multi, ["" + (_this.key('SOURCE'))].concat(__slice.call(res.reverse())));
            multi.del("" + (_this.key('QUEUED')) + ":" + task[1]);
            return multi.exec(function(err, res) {
              if (!res) {
                return requeue();
              }
              return _this._try_exit();
            });
          });
        })();
      }
      start_time = Date.now();
      processing = task[0];
      this.redis.hset(this.key('PROCESSING'), processing, JSON.stringify(__slice.call(task).concat([start_time])));
      retry_count = this.retry_limit;
      errors = [];
      this._handler_callback = handler_callback = function(err, res) {
        var finish_time, multi, process_time;
        _this._handler_callback = null;
        if (err) {
          errors.push(err.message || null);
          switch (err["do"]) {
            case 'block':
              multi = _this.redis.multi();
              multi.rpush(_this.key('FAILED'), JSON.stringify(__slice.call(task).concat([Date.now()], [errors])));
              multi.hdel(_this.key('PROCESSING'), processing);
              multi.sadd(_this.key('BLOCKED'), task[1]);
              multi.exec();
              return _this._poll();
            case 'block-after-retry':
              if (retry_count--) {
                return setTimeout(call_handler, _this.retry_delay);
              }
              multi = _this.redis.multi();
              multi.rpush(_this.key('FAILED'), JSON.stringify(__slice.call(task).concat([Date.now()], [errors])));
              multi.hdel(_this.key('PROCESSING'), processing);
              multi.sadd(_this.key('BLOCKED'), task[1]);
              multi.exec();
              return _this._poll();
            default:
              if (retry_count--) {
                return setTimeout(call_handler, _this.retry_delay);
              }
              multi = _this.redis.multi();
              multi.rpush(_this.key('FAILED'), JSON.stringify(__slice.call(task).concat([Date.now()], [errors])));
              multi.hdel(_this.key('PROCESSING'), processing);
              multi.exec();
          }
        } else {
          multi = _this.redis.multi();
          multi.hdel(_this.key('PROCESSING'), processing);
          finish_time = Date.now();
          process_time = finish_time - start_time;
          multi.hincrby(_this.key('STATISTICS'), 'finished', 1);
          multi.hincrby(_this.key('STATISTICS'), 'total_pending_time', start_time - task[task.length - 1]);
          multi.hincrby(_this.key('STATISTICS'), 'total_processing_time', process_time);
          multi.lpush(_this.key('RECENT'), JSON.stringify(__slice.call(task).concat([finish_time])));
          multi.ltrim(_this.key('RECENT'), 0, _this.recent_size - 1);
          multi.zadd(_this.key('SLOWEST'), process_time, JSON.stringify(task));
          multi.zremrangebyrank(_this.key('SLOWEST'), 0, -_this.slowest_size - 1);
          multi.exec();
        }
        return _this._continue_group(task[1]);
      };
      return (call_handler = function() {
        return _this.handler.apply(_this, __slice.call(task.slice(1, -1)).concat([(_this._handler_callback = handler_callback)]));
      })();
    };

    Queue.prototype._continue_group = function(group) {
      var multi,
        _this = this;
      this.redis.watch("" + (this.key('QUEUED')) + ":" + group);
      multi = this.redis.multi();
      multi.lpop("" + (this.key('QUEUED')) + ":" + group);
      multi.lindex("" + (this.key('QUEUED')) + ":" + group, 0);
      return multi.exec(function(multi_err, multi_res) {
        if (!multi_res) {
          return _this._continue_group(group);
        }
        if (multi_res[1]) {
          return _this._process(JSON.parse(multi_res[1]), true);
        } else {
          return _this._poll();
        }
      });
    };

    Queue.prototype.reschedule = function(callback) {
      var _this = this;
      this.redis.watch(this.key('FAILED'));
      this.redis.watch(this.key('BLOCKED'));
      return this.failed_tasks(function(tasks) {
        var requeued_tasks;
        requeued_tasks = [];
        requeued_tasks.push.apply(requeued_tasks, tasks.map(function(task) {
          return JSON.stringify(task.slice(0, -2));
        }));
        return _this.blocked_groups(function(groups) {
          var group, start_transaction, total_groups, _i, _len, _ref, _results;
          if (groups.length) {
            (_ref = _this.redis).watch.apply(_ref, groups.map(function(group) {
              return "" + (_this.key('QUEUED')) + ":" + group;
            }));
          }
          start_transaction = function() {
            var multi;
            multi = _this.redis.multi();
            if (requeued_tasks.length) {
              multi.rpush.apply(multi, [_this.key('SOURCE')].concat(__slice.call(requeued_tasks)));
            }
            multi.del(_this.key('FAILED'));
            if (groups.length) {
              multi.del.apply(multi, groups.map(function(group) {
                return "" + (_this.key('QUEUED')) + ":" + group;
              }));
            }
            multi.del(_this.key('BLOCKED'));
            multi.del(_this.key('PROCESSING'));
            return multi.exec(function(multi_err, multi_res) {
              if (multi_res) {
                if (callback) {
                  return _this.statistics(callback);
                }
              } else {
                return _this.reschedule(callback);
              }
            });
          };
          if (total_groups = groups.length) {
            _results = [];
            for (_i = 0, _len = groups.length; _i < _len; _i++) {
              group = groups[_i];
              _results.push(_this.redis.lrange("" + (_this.key('QUEUED')) + ":" + group, 1, -1, function(err, res) {
                requeued_tasks.push.apply(requeued_tasks, res);
                if (!--total_groups) {
                  return start_transaction();
                }
              }));
            }
            return _results;
          } else {
            return start_transaction();
          }
        });
      });
    };

    Queue.prototype.recently_finished_tasks = function(callback) {
      return this.redis.lrange(this.key('RECENT'), 0, -1, function(err, res) {
        return callback(res.map(function(entry) {
          return JSON.parse(entry);
        }));
      });
    };

    Queue.prototype.failed_tasks = function(callback) {
      return this.redis.lrange(this.key('FAILED'), 0, -1, function(err, res) {
        return callback(res.map(function(entry) {
          return JSON.parse(entry);
        }));
      });
    };

    Queue.prototype.blocked_groups = function(callback) {
      return this.redis.smembers(this.key('BLOCKED'), function(err, res) {
        return callback(res.map(function(entry) {
          return JSON.parse(entry);
        }));
      });
    };

    Queue.prototype.slowest_tasks = function(callback) {
      return this.redis.zrevrange(this.key('SLOWEST'), 0, -1, "WITHSCORES", function(err, res) {
        var i;
        res = res.map(function(entry) {
          return JSON.parse(entry);
        });
        return callback((function() {
          var _i, _ref, _results;
          _results = [];
          for (i = _i = 0, _ref = res.length; _i < _ref; i = _i += 2) {
            _results.push(__slice.call(res[i]).concat([res[i + 1]]));
          }
          return _results;
        })());
      });
    };

    Queue.prototype.processing_tasks = function(callback) {
      return this.redis.hvals(this.key('PROCESSING'), function(err, res) {
        return callback(res.map(function(entry) {
          return JSON.parse(entry);
        }));
      });
    };

    Queue.prototype.workers = function(callback) {
      return this.redis.hvals(this.key('WORKERS'), function(err, res) {
        return callback(res.map(function(entry) {
          var segments;
          segments = entry.split('|');
          return {
            host: segments[0],
            ip: segments[1],
            pid: parseInt(segments[2]),
            start: parseInt(segments[3])
          };
        }));
      });
    };

    Queue.prototype.clear = function(callback) {
      var _this = this;
      this.redis.watch(this.key('SOURCE'));
      return this.redis.keys("" + (this.key('QUEUED')) + ":*", function(err, res) {
        var multi;
        multi = _this.redis.multi();
        multi.del.apply(multi, [_this.key('GROUPS'), _this.key('RECENT'), _this.key('FAILED'), _this.key('SOURCE'), _this.key('STATISTICS'), _this.key('SLOWEST'), _this.key('BLOCKED')].concat(__slice.call(res)));
        return multi.exec(function(err, res) {
          if (!res) {
            return _this.clear(callback);
          }
          return _this.statistics(callback);
        });
      });
    };

    Queue.prototype.statistics = function(callback) {
      var multi,
        _this = this;
      if (typeof callback !== 'function') {
        return;
      }
      multi = this.redis.multi();
      multi.scard(this.key('GROUPS'));
      multi.hgetall(this.key('STATISTICS'));
      multi.hlen(this.key('PROCESSING'));
      multi.llen(this.key('FAILED'));
      multi.smembers(this.key('BLOCKED'));
      multi.hlen(this.key('WORKERS'));
      return multi.exec(function(multi_err, multi_res) {
        var group, multi2, result, statistics, _i, _len, _ref;
        statistics = multi_res[1] || {};
        result = {
          name: _this.name,
          total: {
            groups: multi_res[0],
            tasks: statistics.total || 0
          },
          finished_tasks: statistics.finished || 0,
          average_pending_time: Math.round(statistics.total_pending_time * 100 / statistics.finished) / 100,
          average_processing_time: Math.round(statistics.total_processing_time * 100 / statistics.finished) / 100,
          blocked: {}
        };
        if (!result.finished_tasks) {
          result.average_pending_time = '-';
          result.average_processing_time = '-';
        }
        result.processing_tasks = multi_res[2];
        result.failed_tasks = multi_res[3];
        result.workers = multi_res[5];
        result.blocked.groups = multi_res[4].length;
        multi2 = _this.redis.multi();
        _ref = multi_res[4];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          group = _ref[_i];
          multi2.llen("" + (_this.key('QUEUED')) + ":" + group);
        }
        return multi2.exec(function(multi2_err, multi2_res) {
          result.blocked.tasks = multi2_res.reduce((function(a, b) {
            return a + b;
          }), -result.blocked.groups);
          result.pending_tasks = result.total.tasks - result.finished_tasks - result.processing_tasks - result.failed_tasks - result.blocked.tasks;
          return callback(result);
        });
      });
    };

    return Queue;

  })();

}).call(this);
